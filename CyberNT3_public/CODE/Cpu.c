/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : Cpu.C
**     Project   : CyberNT3
**     Processor : 56F8366
**     Component : 56F8366
**     Version   : Component 01.020, Driver 02.08, CPU db: 2.87.042
**     Datasheet : MC56F8356/D Rev. 2.0, MC56F8300UM/D - Rev. 1.0
**     Compiler  : Metrowerks DSP C Compiler
**     Date/Time : 2011/8/20, 22:03
**     Abstract  :
**
**     Settings  :
**
**     Contents  :
**         Delay100US - asm void Cpu_Delay100US(word us100);
**
**     (c) Freescale Semiconductor
**     2004 All Rights Reserved
**
**     Copyright : 1997 - 2009 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE Cpu. */
#include "DRV_RL.h"
#include "DRV_RH.h"
#include "DRV_LL.h"
#include "DRV_LH.h"
#include "DRV_BYTE.h"
#include "DRV_PS.h"
#include "AFE_I2C.h"
#include "Inhr4.h"
#include "Inhr5.h"
#include "AFE_FRST.h"
#include "AFE_VSYNC.h"
#include "AFE_HSYNC.h"
#include "TMR.h"
#include "LEFTPA.h"
#include "RIGHTPA.h"
#include "AS.h"
#include "PID.h"
#include "BATT.h"
#include "MFR.h"
#include "HMI_SS.h"
#include "HMI_SPI.h"
#include "Inhr1.h"
#include "Inhr2.h"
#include "Inhr3.h"
#include "HMI_BUZZ.h"
#include "HMI_KEY.h"
#include "PE_Types.h"
#include "PE_Error.h"
#include "PE_Const.h"
#include "IO_Map.h"
#include "PE_Timer.h"
#include "Events.h"
#include "Cpu.h"


/* Global variables */
volatile word SR_lock = 0;             /* Lock */
volatile word SR_reg;                  /* Current value of the SR register */
/*
** ===================================================================
**     Method      :  Cpu_Interrupt (component 56F8366)
**
**     Description :
**         The method services unhandled interrupt vectors.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma interrupt alignsp
void Cpu_Interrupt(void)
{
  asm(DEBUGHLT);                       /* Halt the core and placing it in the debug processing state */
}

/*
** ===================================================================
**     Method      :  Cpu__ivINT_GPIO_D (component 56F8366)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
#pragma interrupt alignsp saveall
void Cpu__ivINT_GPIO_D(void)
{
  word regIntFlag_GPIO_D_IPR = getReg(GPIO_D_IPR);

  if (regIntFlag_GPIO_D_IPR & GPIO_D_IPR_IP0_MASK) /* Is an interrupt flag set? */
  setReg16(GPIO_D_IESR, GPIO_D_IESR_IES0_MASK);
  if (regIntFlag_GPIO_D_IPR & GPIO_D_IPR_IP1_MASK) /* Is an interrupt flag set? */
  setReg16(GPIO_D_IESR, GPIO_D_IESR_IES1_MASK);
  if (regIntFlag_GPIO_D_IPR & GPIO_D_IPR_IP0_MASK) { /* Is the interrupt flag set? */
    AFE_VSYNC_OnInterrupt();           /* Call the service routine */
  }
  if (regIntFlag_GPIO_D_IPR & GPIO_D_IPR_IP1_MASK) { /* Is the interrupt flag set? */
    AFE_HSYNC_OnInterrupt();           /* Call the service routine */
  }
}

/*
** ===================================================================
**     Method      :  Cpu_Delay100US (component 56F8366)
**
**     Description :
**         This method realizes software delay. The length of delay
**         is at least 100 microsecond multiply input parameter
**         [us100]. As the delay implementation is not based on real
**         clock, the delay time may be increased by interrupt
**         service routines processed during the delay. Adding read
**         wait states for external program memory can cause delay
**         extension as well. The method is independent on selected
**         speed mode.
**     Parameters  :
**         NAME            - DESCRIPTION
**         us100           - Number of 100 us delay repetitions.
**     Returns     : Nothing
** ===================================================================
*/
/*lint -save -e???? Disable MISRA rule (all) checking. */
asm void Cpu_Delay100US(word us100)
{
  /* Total irremovable overhead: about 16 cycles */
  /* move.w: 2 cycles overhead (load parameter into register) */
  /* jsr:    5 cycles overhead (jump to subroutine) */
  /* rts:    8 cycles overhead (return from subroutine) */
  /* nop:    1 cycles overhead (aditional nops) */

  loop:
  /* 100 us delay block begin */
  /*
   * Delay
   *   - requested                  : 100 us @ 80MHz,
   *   - possible                   : 8000 c, 100000 ns
   *   - without removable overhead : 7994 c, 99925 ns
   */
  adda #2, SP                          /* (1 c: 12.5 ns) move SP forward */
  move.l A10, X:(SP)                   /* (2 c: 25 ns) push A */
  move.w #3989, A                      /* (2 c: 25 ns) number of iterations */
  do A, label0                         /* (8 c: 100 ns) repeat 3989x nop */
    nop                                /* (1 c: 12.5 ns) wait for 1 c */
  label0:
  move.l X:(SP), A                     /* (2 c: 25 ns) pop A */
  suba #2, SP                          /* (1 c: 12.5 ns) move SP back */
  /* 100 us delay block end */
  dec.w Y0                             /* us100 parameter is passed via Y0 register */
  jne loop                             /* next loop */
  nop                                  /* avoid pipeline conflicts */
  rts                                  /* return from subroutine */
}
/*lint -restore */

/*
** ===================================================================
**     Method      :  _EntryPoint (component 56F8366)
**
**     Description :
**         Initializes the whole system like timing and so on. At the end 
**         of this function, the C startup is invoked to initialize stack,
**         memory areas and so on.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
extern void init_56800_(void);         /* Forward declaration of external startup function declared in startup file */

/*** !!! Here you can place your own code using property "User data declarations" on the build options tab. !!! ***/

void _EntryPoint(void)
{
  #pragma constarray off

  /*** !!! Here you can place your own code before PE initialization using property "User code before PE initialization" on the build options tab. !!! ***/

  /*** ### 56F8366 "Cpu" init code ... ***/
  /*** PE initialization code after reset ***/
  /* System clock initialization */
  setReg(PLLCR, (PLLCR_LCKON_MASK | PLLCR_ZSRC0_MASK)); /* Enable PLL, LCKON and select clock source from prescaler */
  /* PLLDB: LORTP=2,PLLCOD=0,PLLCID=1,??=0,PLLDB=79 */
  setReg16(PLLDB, 8527U);              /* Set the clock prescalers */ 
  while(!getRegBit(PLLSR, LCK0)){}     /* Wait for PLL lock */
  setReg(PLLCR, (PLLCR_LCKON_MASK | PLLCR_ZSRC1_MASK)); /* Select clock source from postscaler */
  /* FMCLKD: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,DIVLD=0,PRDIV8=1,DIV=25 */
  setReg16(FMCLKD, 89U);               /* Set the flash clock prescaler */ 
  /* External bus initialization */
  /* SEMI_BCR: DRV=1,BMDAR=0,??=0,??=0,BWWS=0,BRWS=0 */
  setReg16(SEMI_BCR, 32768U);          /* Bus control register */ 
  /*** End of PE initialization code after reset ***/

  /*** !!! Here you can place your own code after PE initialization using property "User code after PE initialization" on the build options tab. !!! ***/

  asm(JMP init_56800_);                /* Jump to C startup code */
}

/*
** ===================================================================
**     Method      :  PE_low_level_init (component 56F8366)
**
**     Description :
**         Initializes beans and provides common register initialization. 
**         The method is called automatically as a part of the 
**         application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void PE_low_level_init(void)
{
  /* DEC0_FIR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,DELAY=0 */
  setReg16(DEC0_FIR, 0U);              /* Set up Filter Interval Register of Quadrature Decoder 0 */ 
  /* DEC1_FIR: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,DELAY=0 */
  setReg16(DEC1_FIR, 0U);              /* Set up Filter Interval Register of Quadrature Decoder 1 */ 
  /* SIM_PCE: EMI=1,ADC_B=1,ADC_A=1,CAN=1,DEC_1=1,DEC_0=1,TMR_D=1,TMR_C=1,TMR_B=1,TMR_A=1,SCI_1=1,SCI_0=1,SPI_1=1,SPI_0=1,PWM_B=1,PWM_A=1 */
  setReg16(SIM_PCE, 65535U);           /* Set up the peripheral clock enable register */ 
  /* SIM_PCE2: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,CAN2=1 */
  setReg16(SIM_PCE2, 1U);              /* Set up the peripheral clock enable register */ 
  /* SIM_CONTROL: ??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,emi_mode=0,OnceEbl=0,SWRst=0,stop_disable=0,wait_disable=0 */
  setReg16(SIM_CONTROL, 0U);           /* Set up the SIM control register */ 
  /* SIM_CLKOSR: ??=0,??=0,??=0,??=0,??=0,??=0,A23_b=0,A22_b=0,A21_b=0,A20_b=0,CLKDIS=1,CLKOSEL=0 */
  setReg16(SIM_CLKOSR, 32U);           /* Set up the SIM clock output select register */ 
  /* TSENSOR_CONTROL: PWR=0 */
  clrReg16Bits(TSENSOR_CONTROL, 1U);   /* Disable power source for the temperature sensor */ 
  /* Common initialization of the CPU registers */
  /* GPIO_A_IENR: IEN&=~255 */
  clrReg16Bits(GPIO_A_IENR, 255U);      
  /* GPIO_A_IAR: IA&=~255 */
  clrReg16Bits(GPIO_A_IAR, 255U);       
  /* GPIO_A_IESR: IES|=255 */
  setReg16Bits(GPIO_A_IESR, 255U);      
  /* GPIO_A_PPMODE: PPMODE|=255 */
  setReg16Bits(GPIO_A_PPMODE, 255U);    
  /* GPIO_A_DR: D&=~255 */
  clrReg16Bits(GPIO_A_DR, 255U);        
  /* GPIO_A_DDR: DD|=255 */
  setReg16Bits(GPIO_A_DDR, 255U);       
  /* GPIO_A_PER: PE&=~255 */
  clrReg16Bits(GPIO_A_PER, 255U);       
  /* GPIO_E_PER: PE8=1,PE7=0,PE6=0,PE5=0,PE4=0 */
  clrSetReg16Bits(GPIO_E_PER, 240U, 256U); 
  /* GPIO_D_IENR: IEN12=0,IEN11=0,IEN8=0 */
  clrReg16Bits(GPIO_D_IENR, 6400U);     
  /* GPIO_D_IAR: IA12=0,IA11=0,IA8=0,IA1=0,IA0=0 */
  clrReg16Bits(GPIO_D_IAR, 6403U);      
  /* GPIO_D_IESR: IES12=1,IES11=1,IES8=1 */
  setReg16Bits(GPIO_D_IESR, 6400U);     
  /* GPIO_D_PUR: PU12=1,PU11=1,PU1=1,PU0=1 */
  setReg16Bits(GPIO_D_PUR, 6147U);      
  /* GPIO_D_PPMODE: PPMODE12=1,PPMODE11=1,PPMODE8=1 */
  setReg16Bits(GPIO_D_PPMODE, 6400U);   
  /* GPIO_D_DR: D12=1,D11=1,D8=0 */
  clrSetReg16Bits(GPIO_D_DR, 256U, 6144U); 
  /* GPIO_D_DDR: DD12=0,DD11=0,DD8=1,DD1=0,DD0=0 */
  clrSetReg16Bits(GPIO_D_DDR, 6147U, 256U); 
  /* GPIO_D_PER: PE12=0,PE11=0,PE8=0,PE7=1,PE6=1,PE1=0,PE0=0 */
  clrSetReg16Bits(GPIO_D_PER, 6403U, 192U); 
  /* INTC_IPR3: GPIO_D_IPL=3 */
  setReg16Bits(INTC_IPR3, 49152U);      
  /* GPIO_D_IPR: IP1=0,IP0=0 */
  clrReg16Bits(GPIO_D_IPR, 3U);         
  /* GPIO_D_IPOLR: IPOL1=1,IPOL0=1 */
  setReg16Bits(GPIO_D_IPOLR, 3U);       
  /* INTC_IPR7: TMRA_0_IPL=2 */
  clrSetReg16Bits(INTC_IPR7, 16384U, 32768U); 
  /* GPIO_C_PER: PE|=240 */
  setReg16Bits(GPIO_C_PER, 240U);       
  /* GPIO_C_PUR: PU&=~240 */
  clrReg16Bits(GPIO_C_PUR, 240U);       
  /* INTC_IPR5: SCI1_RCV_IPL=2,SCI1_RERR_IPL=2,SCI1_TIDL_IPL=2,SCI1_XMIT_IPL=2 */
  clrSetReg16Bits(INTC_IPR5, 1300U, 2600U); 
  /* GPIO_E_IENR: IEN7=0,IEN6=0,IEN5=0,IEN4=0 */
  clrReg16Bits(GPIO_E_IENR, 240U);      
  /* GPIO_E_IAR: IA7=0,IA6=0,IA5=0,IA4=0 */
  clrReg16Bits(GPIO_E_IAR, 240U);       
  /* GPIO_E_IESR: IES7=1,IES6=1,IES5=1,IES4=1 */
  setReg16Bits(GPIO_E_IESR, 240U);      
  /* GPIO_E_PPMODE: PPMODE7=1,PPMODE5=1,PPMODE4=1 */
  setReg16Bits(GPIO_E_PPMODE, 176U);    
  /* GPIO_E_DR: D7=1,D5=0,D4=0 */
  clrSetReg16Bits(GPIO_E_DR, 48U, 128U); 
  /* GPIO_E_DDR: DD7=1,DD6=0,DD5=1,DD4=1 */
  clrSetReg16Bits(GPIO_E_DDR, 64U, 176U); 
  /* GPIO_E_PUR: PU6=0 */
  clrReg16Bits(GPIO_E_PUR, 64U);        
  /* GPIO_F_PER: PE|=65025 */
  setReg16Bits(GPIO_F_PER, 65025U);     
  /* ### Programable pulse generation "DRV_RL" init code ... */
  DRV_RL_Init();
  /* ### Programable pulse generation "DRV_RH" init code ... */
  DRV_RH_Init();
  /* ### Programable pulse generation "DRV_LL" init code ... */
  DRV_LL_Init();
  /* ### Programable pulse generation "DRV_LH" init code ... */
  DRV_LH_Init();
  /* ### ByteIO "DRV_BYTE" init code ... */
  /* ### PulseStream "DRV_PS" init code ... */
  DRV_PS_Init();
  /* ###  "AFE_I2C" init code ... */
  AFE_I2C_Init();
  /* ### TimerInt "TMR" init code ... */
  TMR_Init();
  /* ### PulseAccumulator "LEFTPA" init code ... */
  LEFTPA_Init();
  /* ### PulseAccumulator "RIGHTPA" init code ... */
  RIGHTPA_Init();
  /* ### Asynchro serial "AS" init code ... */
  AS_Init();
  /* ### ADC "BATT" init code ... */
  BATT_Init();
  /* ### SWSPI "HMI_SPI" init code ... */
  HMI_SPI_Init();
  /* ### Programable pulse generation "HMI_BUZZ" init code ... */
  HMI_BUZZ_Init();
  /* ### ADC "HMI_KEY" init code ... */
  HMI_KEY_Init();
  /* Common peripheral initialization - ENABLE */
  /* PWMB_PMOUT: OUTCTL&=~15 */
  clrReg16Bits(PWMB_PMOUT, 3840U);      
  /* PWMB_PMCCR: MSK&=~15 */
  clrReg16Bits(PWMB_PMCCR, 3840U);      
  /* GPIO_D_IENR: IEN1=0,IEN0=0 */
  clrReg16Bits(GPIO_D_IENR, 3U);        
  /* PWMA_PMOUT: OUTCTL&=~32 */
  clrReg16Bits(PWMA_PMOUT, 8192U);      
  /* PWMA_PMCCR: MSK&=~32 */
  clrReg16Bits(PWMA_PMCCR, 8192U);      
  setRegBit(PWMB_PMOUT,PAD_EN);        /* Enable output */
  setRegBits(PWMB_PMCTL,3);            /* Run counter */
  setRegBit(PWMA_PMOUT,PAD_EN);        /* Enable output */
  setRegBits(PWMA_PMCTL,3);            /* Run counter */
  __EI(0);                             /* Enable interrupts of the selected priority level */
}

/* END Cpu. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 3.00 [04.35]
**     for the Freescale 56800 series of microcontrollers.
**
** ###################################################################
*/
