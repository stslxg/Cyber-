/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : PID.C
**     Project   : CyberNT3
**     Processor : 56F8366
**     Component : MC_PIController
**     Version   : Component 01.018, Driver 01.03, CPU db: 2.87.042
**     Compiler  : Metrowerks DSP C Compiler
**     Date/Time : 2011/8/20, 22:03
**     Abstract  :
**          This bean encapsulate the API for standard controllers (e.g., PI and PID)
**          for use in motor control applications in general.
**     Settings  :
**          This bean has no settings.
**     Contents  :
**         controllerPItype1  - Word16 PID_controllerPItype1(Word16 DesiredValue, Word16 MeasuredValue,...
**         controllerPIDtype1 - Word16 PID_controllerPIDtype1(Word16 DesiredValue, Word16 MeasuredValue,...
**
**     (c) Freescale Semiconductor
**     2004 All Rights Reserved
**
**     Copyright : 1997 - 2009 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE PID. */

#include "PID.h"
#include "prototype.h"

/*
** ===================================================================
**     Method      :  PID_controllerPIDtype1 (component MC_PIController)
**
**     Description :
**         This function calculates the PID
**         (Proportional-Integral-Derivative) algorithm.
**     Parameters  :
**         NAME            - DESCRIPTION
**         DesiredValue    - Desired value.
**         MeasuredValue   - Measured value.
**       * pParams         - Pointer to variable containing
**                           controller parameters, the integral
**                           portion in k-1 step and the iput error
**                           in step k-1.
**     Returns     :
**         ---             - This function returns the value
**                           representing the controller output in
**                           step k. The output value is limited by
**                           using PositivePIDLimit and
**                           NegativePIDLimit values.
** ===================================================================
*/
Word16 PID_controllerPIDtype1(Word16 DesiredValue,Word16 MeasuredValue,mc_sPIDparams *pParams)
{
  Word32 ProportionalPortion, IntegralPortion, PIDoutput;
  Word16 InputError;

  /*-------------------------------------------------------------------------------------------------*/
  /* Saturation mode must be set */
  /* InputError = sub(DesiredValue, MeasuredValue); */  /* input error */
  /*-------------------------------------------------------------------------------------------------*/
  /* input error calculation - 16bit range, with and without saturation mode  */
  PIDoutput = L_sub(L_deposit_l(DesiredValue),L_deposit_l(MeasuredValue)); /* input error - 32bit range */
  if(PIDoutput > MAX_16)               /* inpur error is greater than 0x00007fff = 32767  - 32bit range */
    InputError = MAX_16;               /* input error = max. positive 16 bit signed value */
  else
    if(PIDoutput < MIN_16)             /* input error is less than 0xffff7fff = -32768    - 32bit range */
      InputError = MIN_16;             /* input error = min. negative 16 bit signed value */
    else
      InputError = extract_l(PIDoutput); /* input error - 16bit range */

  /*-------------------------------------------------------------------------------------------------*/
  /* proportional portion calculation */
  ProportionalPortion = L_mult((pParams -> ProportionalGain), InputError) >> (pParams -> ProportionalGainScale + 1);

  /*-------------------------------------------------------------------------------------------------*/
  /* integral portion calculation */
  IntegralPortion = L_mult((pParams -> IntegralGain), InputError) >> (pParams -> IntegralGainScale + 1);

  /* integral portion in step k + integral portion in step k-1 */
  IntegralPortion = L_add(IntegralPortion, L_deposit_l(pParams -> IntegralPortionK_1));

  /* integral portion limitation */
  if(IntegralPortion > pParams -> PositivePIDLimit)
    pParams -> IntegralPortionK_1 = pParams -> PositivePIDLimit;
  else
    if(IntegralPortion < pParams -> NegativePIDLimit)
      pParams -> IntegralPortionK_1 =  pParams -> NegativePIDLimit;
    else
      pParams -> IntegralPortionK_1 =  extract_l(IntegralPortion);

  /*-------------------------------------------------------------------------------------------------*/
  /* derivative portion calculation */
  PIDoutput = L_sub(L_deposit_l(InputError),L_deposit_l(pParams -> InputErrorK_1)); /* [e(k) - e(k-1)] - 32bit range */
  pParams -> InputErrorK_1 = InputError; /* e(k-1) = e(k) */
  if(PIDoutput > MAX_16)               /* [e(k) - e(k-1)] is greater than 0x00007fff = 32767  - 32bit range */
    InputError = MAX_16;               /* [e(k) - e(k-1)] = max. positive 16 bit signed value - 16 bit range */
  else
    if(PIDoutput < MIN_16)             /* [e(k) - e(k-1)] is less than 0xffff7fff = -32768    - 32bit range */
      InputError = MIN_16;             /* [e(k) - e(k-1)] = min. negative 16 bit signed value - 16 bit range */
    else
      InputError = extract_l(PIDoutput); /* [e(k) - e(k-1)]    - 16bit range */

  /* drivative portion in step k - integer */
  PIDoutput = L_mult((pParams -> DerivativeGain), InputError) >> (pParams -> DerivativeGainScale + 1);

  /*-------------------------------------------------------------------------------------------------*/
  /* controller output calculation */
  PIDoutput = L_add(PIDoutput, ProportionalPortion); /* derivative portion + proportional portion */
  PIDoutput = L_add(PIDoutput, L_deposit_l(pParams -> IntegralPortionK_1)); /* + integral portion = controller output */

  /* controller output limitation */
  if(PIDoutput > pParams -> PositivePIDLimit)
    PIDoutput = pParams -> PositivePIDLimit;
  else
    if(PIDoutput < pParams -> NegativePIDLimit)
      PIDoutput =  pParams -> NegativePIDLimit;

  /*-------------------------------------------------------------------------------------------------*/

  return (extract_l(PIDoutput));  /* controller output with limitation */
}

/*
** ===================================================================
**     Method      :  PID_controllerPItype1 (component MC_PIController)
**
**     Description :
**         This function calculates the PI (Proportional-Integral)
**         algorithm.
**     Parameters  :
**         NAME            - DESCRIPTION
**         DesiredValue    - Desired value.
**         MeasuredValue   - Measured value.
**       * pParams         - Pointer to variable containing
**                           controller parameters and the integral
**                           portion in k-1 step.
**     Returns     :
**         ---             - This function returns the value
**                           representing the controller output in
**                           step k. The output value is limited by
**                           using PositivePILimit and
**                           NegativePILimit values.
** ===================================================================
*/
Word16 PID_controllerPItype1(Word16 DesiredValue,Word16 MeasuredValue,mc_sPIparams *pParams)
{
  Word32 ProportionalPortion, IntegralPortion, PIoutput;
  Word16 InputError;

  /*-------------------------------------------------------------------------------------------------*/
  /* Saturation mode must be set */
  /*   InputError = sub(DesiredValue, MeasuredValue); */  /* input error */
  /*-------------------------------------------------------------------------------------------------*/
  /* input error calculation - 16bit range, with and without saturation mode  */

  PIoutput = L_sub(L_deposit_l(DesiredValue),L_deposit_l(MeasuredValue)); /* input error - 32bit range */
  if(PIoutput > MAX_16)                /* inpur error is greater than 0x00007fff = 32767  - 32bit range */
    InputError = MAX_16;               /* input error = max. positive 16 bit signed value */
  else
    if(PIoutput < MIN_16)              /* input error is less than 0xffff7fff = -32768    - 32bit range */
      InputError = MIN_16;             /* input error = min. negative 16 bit signed value */
    else
      InputError = extract_l(PIoutput); /* input error - 16bit range */

  /*-------------------------------------------------------------------------------------------------*/
  /* proportional portion calculation */

  ProportionalPortion = L_mult((pParams -> ProportionalGain), InputError) >> (pParams -> ProportionalGainScale + 1);

  /*-------------------------------------------------------------------------------------------------*/
  /* integral portion calculation */

  IntegralPortion = L_mult((pParams -> IntegralGain), InputError) >> (pParams -> IntegralGainScale + 1);

  /* integral portion in step k + integral portion in step k-1 */
  IntegralPortion = L_add(IntegralPortion, L_deposit_l(pParams -> IntegralPortionK_1));

  /* integral portion limitation */
  if(IntegralPortion > pParams -> PositivePILimit)
    pParams -> IntegralPortionK_1 = pParams -> PositivePILimit;
  else
    if(IntegralPortion < pParams -> NegativePILimit)
      pParams -> IntegralPortionK_1 =  pParams -> NegativePILimit;
    else
      pParams -> IntegralPortionK_1 =  extract_l(IntegralPortion);

  /*-------------------------------------------------------------------------------------------------*/
  /* controller output calculation */
  /* proportional portion + integral portion */
  PIoutput = L_add(ProportionalPortion, L_deposit_l(pParams -> IntegralPortionK_1)); /* controller output */

  /* controller output limitation */
  if(PIoutput > pParams -> PositivePILimit)
    PIoutput = pParams -> PositivePILimit;
  else
    if(PIoutput < pParams -> NegativePILimit)
      PIoutput =  pParams -> NegativePILimit;

  return (extract_l(PIoutput));        /* controller output with limitation */
}

/* END PID. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 3.00 [04.35]
**     for the Freescale 56800 series of microcontrollers.
**
** ###################################################################
*/
