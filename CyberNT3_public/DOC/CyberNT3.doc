=============================================================================
List of generated methods in project: CyberNT3

THIS TEXT DESCRIPTION IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
=============================================================================

Module "DRV_RL"    (bean PWM)
   - DRV_RL_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.

Module "DRV_RH"    (bean PWM)
   - DRV_RH_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.

Module "DRV_LL"    (bean PWM)
   - DRV_LL_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.

Module "DRV_LH"    (bean PWM)
   - DRV_LH_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.

Module "DRV_BYTE"  (bean ByteIO)
   - DRV_BYTE_PutVal -Specified value is passed to the Input/Output component. If the direction is [input] saves the value to a 
                memory or a register, this value will be written to the pins after switching to the output mode - using 
                [SetDir(TRUE)] (see <Safe mode> property for limitations). If the direction is [output] it writes the value to 
                the port. (Method is available only if the Direction = _[output]_ or _[input/output]_).

Module "DRV_PS"    (bean PulseStream)
   - DRV_PS_Enable -Enables the component - starts the signal generation. This method must be generated. After all pulses are 
                generated, the component is automatically disabled (and event < OnEnd > may be generated).
   - DRV_PS_SetClockTicks16 -This method sets the new pulse width of the clock signal. The pulse width is expressed in CPU 
                [ticks] as a 16-bit unsigned integer number. This method is only available for external clock source and only 
                when the runtime setting type 'from interval' is selected in the <Timing dialog box> of Runtime setting area.

Module "AFE_I2C"   (bean SW_I2C)
   - AFE_I2C_SendBlock -When working as a MASTER, this method writes 7 bits of slave address plus R/W bit = 0 to the I2C bus 
                and then writes the block of characters to the bus. If the component is disabled (by the "Disable" method or 
                initialization), the block is moved to the output buffer if the <Output buffer size> property is different from 
                zero. The content of the output buffer is sent immediately with the stop condition at the end when the 
                component is enabled by the "Enable" method. After the output buffer transmission, the whole output buffer is 
                cleared. The slave address must be specified before by the "SelectSlave" method or in component initialization 
                section of <Slave address init> property. When working as a SLAVE, this method writes block of characters to 
                the bus. If the ERR_NOTAVAIL error code is returned, the whole block is successfully sent to a master but the 
                master device responds by an acknowledgement instead of no acknowledgment sent at the end of the last block 
                byte transfer. <OnError> event is called in this case.
   - AFE_I2C_SelectSlave -When working as a MASTER, this method selects a new slave for communication by its slave address 
                value. Any send or receive method are directed to or from the selected device, until a new slave device is 
                selected by this method. If the selected slave uses 10-bit slave addressing, as the parameter 7 bits must be 
                passed, which involves 10-bit addressing (11110XX), including two MSBs of slave address (XX). The second byte 
                of the 10-bit slave address must be sent to the slave as a general character of send methods. This method is 
                available only if the component is in MASTER mode.

Module "AFE_FRST"  (bean BitIO)
   - AFE_FRST_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - AFE_FRST_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.

Module "AFE_VSYNC" (bean ExtInt)
   - AFE_VSYNC_Enable -Enable the component - the external events are accepted. This method is available only if HW module 
                allows enable/disable of the interrupt.

Module "AFE_HSYNC" (bean ExtInt)
   - AFE_HSYNC_Enable -Enable the component - the external events are accepted. This method is available only if HW module 
                allows enable/disable of the interrupt.

Module "TMR"       (bean TimerInt)

Module "LEFTPA"    (bean PulseAccumulator)
   - LEFTPA_GetCounterValue -This method returns the content of the pulse accumulator counter.

Module "RIGHTPA"   (bean PulseAccumulator)
   - RIGHTPA_GetCounterValue -This method returns the content of the pulse accumulator counter.

Module "AS"        (bean AsynchroSerial)
   - AS_RecvChar -If any data is received, this method returns one character, otherwise it returns an error code (it does not 
                wait for data). This method is enabled only if the receiver property is enabled.  [Note:] Because the preferred 
                method to handle error and break exception in the interrupt mode is to use events <OnError> and <OnBreak> the 
                return value ERR_RXEMPTY has higher priority than other error codes. As a consequence the information about an 
                exception in interrupt mode is returned only if there is a valid character ready to be read. Version specific 
                information for Freescale 56800 derivatives ]   DMA mode:  If DMA controller is available on the selected CPU 
                and the receiver is configured to use DMA controller then this method only sets the selected DMA channel. Then 
                the status of the DMA transfer can be checked using GetCharsInRxBuf method. See an example of a typical usage 
                for details about the communication using DMA.
   - AS_SendChar -Sends one character to the channel. If the component is temporarily disabled (Disable method) SendChar method 
                only stores data into an output buffer. In case of a zero output buffer size, only one character can be stored. 
                Enabling the component (Enable method) starts the transmission of the stored data. This method is available 
                only if the transmitter property is enabled.  Version specific information for Freescale 56800 derivatives ]   
                DMA mode:  If DMA controller is available on the selected CPU and the transmitter is configured to use DMA 
                controller then this method only sets selected DMA channel. Then the status of the DMA transfer can be checked 
                using GetCharsInTxBuf method. See an example of a typical usage for details about communication using DMA.
   - AS_SendBlock -Sends a block of characters to the channel.  This method is available only if non-zero length of the output 
                buffer is defined and the transmitter property is enabled.  Version specific information for Freescale 56800 
                derivatives ]   DMA mode:  If DMA controller is available on the selected CPU and the transmitter is configured 
                to use DMA controller then this method only sets the selected DMA channel. Then the status of the DMA transfer 
                can be checked using GetCharsInTxBuf method. See typical usage for details about communication using DMA.
   - AS_ClearTxBuf -Clears the transmit buffer.  This method is available only if non-zero length of the output buffer is 
                defined and the receiver property is enabled. Version specific information for Freescale 56800 derivatives ]   
                DMA mode:  If DMA controller is available on the selected CPU and the transmitter is configured to use DMA 
                controller then this method only stops selected DMA channel.
   - AS_GetCharsInRxBuf -Returns the number of characters in the input buffer. This method is available only if the receiver 
                property is enabled. Version specific information for Freescale 56800 derivatives ]   DMA mode:  If DMA 
                controller is available on the selected CPU and the receiver is configured to use DMA controller then this 
                method returns the number of characters in the receive buffer.
   - AS_GetCharsInTxBuf -Returns the number of characters in the output buffer. This method is available only if the 
                transmitter property is enabled. Version specific information for Freescale 56800 derivatives ]   DMA mode:  If 
                DMA controller is available on the selected CPU and the transmitter is configured to use DMA controller then 
                this method returns the number of characters in the transmit buffer.

Module "PID"       (bean MC_PIController)
   - PID_controllerPItype1 -This function calculates the PI (Proportional-Integral) algorithm.
   - PID_controllerPIDtype1 -This function calculates the PID (Proportional-Integral-Derivative) algorithm.

Module "BATT"      (bean ADC)
   - BATT_Measure -This method performs one measurement on all channels that are set in the component inspector. (Note: If the 
                <number of conversions> is more than one the conversion of A/D channels is performed specified number of times.)
   - BATT_GetValue16 -This method returns the last measured values of all channels justified to the left. Compared with 
                <GetValue> method this method returns more accurate result if the <number of conversions> is greater than 1 and 
                <AD resolution> is less than 16 bits. In addition, the user code dependency on <AD resolution> is eliminated.

Module "MFR"       (bean DSP_Func_MFR)
   - MFR_abs_s -The abs_s function calculates the 16-bit absolute value of the input value.
   - MFR_add -The add function adds two 16-bit fractional numbers (x + y).
   - MFR_div_s -The div_s function divides two fractional numbers (x / y); x and y must be positive and y must be greater than 
                or equal to x.
   - MFR_mac_r -The mac function multiplies two 16-bit fractional input values (x * y) and adds the 32-bit result to w.
   - MFR_msu_r -The msu function multiplies x by y and subtracts the 32-bit result from w.
   - MFR_mult -This multiplication function multiply two fractional input values and return the result.
   - MFR_mult_r -This multiplication function multiply two fractional input values and return the result. The function differs 
                from mult in that function rounds the result, whereas mult truncates the result to 16bits.
   - MFR_negate -The negate function negates the fractional input value.
   - MFR_round -The round function rounds the 32-bit fractional input value to 16 bits.
   - MFR_shl -The shl function arithmetically shifts the input variable x left n positions, zero filling the least significant 
                bits of the result. If n is negative, the shl function arithmetically shifts x right by -n bits with sign 
                extension.
   - MFR_shr -The shr function arithmetically shifts the input variable x right n positions, sign extending the result. If n is 
                negative, the shr function arithmetically shifts x left by -n bits, zero filling the least significant bits.
   - MFR_shr_r -The shr_r function arithmetically shifts the input variable x right n positions, sign extending the result. If 
                n is negative, the shr_r function arithmetically shifts x left by -n bits, zero filling the least significant 
                bits. shr_r differs from shr in that shr_r rounds the 32-bit fractional result.
   - MFR_sub -The sub function calculates (x - y).
   - MFR_L_abs -The L_abs function calculates the 32-bit absolute value of the input value.
   - MFR_L_add -The add function adds two 32-bit fractional numbers (x + y).
   - MFR_div_ls -The div_ls function divides two fractional numbers (x / y); x and y must be positive and y must be greater 
                than or equal to x.
   - MFR_L_mac -The mac function multiplies two 16-bit fractional input values (x * y) and adds the 32-bit result to w.
   - MFR_L_msu -The msu function multiplies x by y and subtracts the 32-bit result from w.
   - MFR_L_mult -This multiplication function multiply two fractional input values and return the result.
   - MFR_L_mult_ls -This multiplication function multiply two fractional input values and return the result. The function 
                differs from mult in that function rounds the result, whereas mult truncates the result to 16bits.
   - MFR_L_negate -The negate function negates the fractional input value.
   - MFR_L_shl -The L_shl function arithmetically shifts the input variable x left n positions, zero filling the least 
                significant bits of the result. If n is negative, the shl function arithmetically shifts x right by -n bits 
                with sign extension.
   - MFR_L_shr -The L_shr function arithmetically shifts the input variable x right n positions, sign extending the result. If 
                n is negative, the L_shr function arithmetically shifts x left by -n bits, zero filling the least significant 
                bits.
   - MFR_L_shr_r -The L_shr_r function arithmetically shifts the input variable x right n positions, sign extending the result. 
                If n is negative, the L_shr_r function arithmetically shifts x left by -n bits, zero filling the least 
                significant bits. L_shr_r differs from L_shr in that L_shr_r rounds the 32-bit fractional result.
   - MFR_L_deposit_h -The L_deposit_h function places a 16-bit fractional value into the most significant 16-bits of the 32-bit 
                fractional output value and zeroes the least significant 16 bits.
   - MFR_L_deposit_l -The L_deposit_l function places a 16-bit fractional value into the least significant 16 bits of the 
                32-bit fractional output value and sign extends the most significant 16 bits.
   - MFR_L_sub -The L_sub function calculates (x - y).
   - MFR_extract_h -The extract_h function extracts the most significant 16 bits from the 32-bit fractional value.
   - MFR_extract_l -The extract_l function extracts the least significant 16 bits from the 32-bit fractional value.
   - MFR_norm_s -The norm function calculates the number of left shifts needed to normalize a fractional value.
   - MFR_norm_l -The norm function calculates the number of left shifts needed to normalize a fractional value.
   - MFR_mfr32Sqrt -The function calculates the square root of the fractional input data value. This method cannot be disabled 
                if Use Assembler Files property is enabled.

Module "HMI_SS"    (bean BitIO)
   - HMI_SS_ClrVal -Clears (set to zero) the output value. It is equivalent to the [PutVal(FALSE)]. This method is available 
                only if the direction = _[output]_ or _[input/output]_.
   - HMI_SS_SetVal -Sets (to one) the output value. It is equivalent to the [PutVal(TRUE)]. This method is available only if 
                the direction = _[output]_ or _[input/output]_.

Module "HMI_SPI"   (bean SWSPI)
   - HMI_SPI_RecvChar -If any data received, this method returns one character, otherwise it returns an error code (it does not 
                wait for data).
   - HMI_SPI_SendChar -Sends one character to the channel.

Module "HMI_BUZZ"  (bean PWM)
   - HMI_BUZZ_SetRatio16 -This method sets a new duty-cycle ratio. Ratio is expressed as a 16-bit unsigned integer number. 0 - 
                FFFF value is proportional to ratio 0 - 100%. The method is available only if it is not selected list of 
                predefined values in <Starting pulse width> property.   Note: Calculated duty depends on the timer 
                possibilities and on the selected period.

Module "HMI_KEY"   (bean ADC)
   - HMI_KEY_Measure -This method performs one measurement on all channels that are set in the component inspector. (Note: If 
                the <number of conversions> is more than one the conversion of A/D channels is performed specified number of 
                times.)
   - HMI_KEY_GetValue16 -This method returns the last measured values of all channels justified to the left. Compared with 
                <GetValue> method this method returns more accurate result if the <number of conversions> is greater than 1 and 
                <AD resolution> is less than 16 bits. In addition, the user code dependency on <AD resolution> is eliminated.

Module "Cpu"       (bean 56F8366)
   - Cpu_Delay100US -This method realizes software delay. The length of delay is at least 100 microsecond multiply input 
                parameter [us100]. As the delay implementation is not based on real clock, the delay time may be increased by 
                interrupt service routines processed during the delay. Adding read wait states for external program memory can 
                cause delay extension as well. The method is independent on selected speed mode.

===================================================================================
